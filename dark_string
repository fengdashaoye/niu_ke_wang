题目描述
一个只包含'A'、'B'和'C'的字符串，如果存在某一段长度为3的连续子串中恰好'A'、'B'和'C'各有一个，那么这个
字符串就是纯净的，否则这个字符串就是暗黑的。例如：
BAACAACCBAAA 连续子串"CBA"中包含了'A','B','C'各一个，所以是纯净的字符串
AABBCCAABB 不存在一个长度为3的连续子串包含'A','B','C',所以是暗黑的字符串
你的任务就是计算出长度为n的字符串(只包含'A'、'B'和'C')，有多少个是暗黑的字符串。
输入描述:
输入一个整数n，表示字符串长度(1 ≤ n ≤ 30)
输出描述:
输出一个整数表示有多少个暗黑字符串
示例1
输入

2 3
输出

9 21

思路：别看这道题代码量很少，但是这道题非常难。首先在审题上需要注意的是求长度为n的字符串中有几条为暗黑串，注意纯净串为这长度为n的字符串
中有长度为3的子串，且该字串分别包含A,B,C.
如对于长度为2的串，其暗黑串为AB,AC,BA,BC,CA,CB,AA,BB,CC，所以输出为9.
网址为：https://www.cnblogs.com/JSONBEAN/p/6433755.html（里面有讲解）
根据动态规划的公式:f(n) = k1 * f(n - 1) + k2 * f(n - 2) + ......ki * f(n - i)。
ki为系数。

那么一条长度为n的暗黑串，肯定与长度为n - 1的暗黑串相关。
对于长度为n - 1的暗黑串，有两种情况，其末尾两个字符相同或者不相同
即f(n - 1) = s(n - 1) + d(n - 1)
结尾字符相同（用s(n-1)表示）
结尾字符不同（用d(n-1)表示）
f(n - 1)表示长度为n - 1的暗黑串的数量。

此时对于长度为n的暗黑串，如果长度为n - 1时暗黑串的末尾两位相同(即s(n - 1))，那么扩展位为A,B,C都可，有3种可能。
如果长度为n - 1时暗黑串的末尾两位不同(即d(n - 1)),扩展位只有两种可能，如对于暗黑串....AB,其扩展位只能是A或者B，如果扩展位为C，则不是暗黑串。
所以f(n) = 3 * s(n - 1) + 2 * d(n - 1)
         = s(n - 1) + 2 * s(n - 1) + 2 * d(n - 1)
         = 2 * f(n - 1) + s(n - 1)
此时s(n - 1)无法消除，因为要看s(n - 1)，此时就需要根据n - 2的暗黑串来得到。
此时把长度n - 1看成m,n - 2 看成 m - 1；
我们要得到s(m)。对于s(m - 1)，因为其末尾两位已经相同，拓展位必须与之前两位相同，才能是扩展后的末尾两位两同。
对于d(m - 1)，其末尾两位不同，扩展位必须与m - 1暗黑串的末尾相同，如....AB,扩展位需为B。
所以S(m) = s(m - 1) + d(m - 1)。再结合最开始的公式f(n - 1) = s(n - 1) + d(n - 1)。
得到s(n) = f(n - 1)。
结合公式f(n) = 2 * f(n - 1) + s(n - 1)
得到f(n) = 2 * f(n - 1) + f(n - 2)

一步步推导，这道题真得不简单，挺难的。看解释都看了一会。。。

代码：
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int number = in.nextInt();
            long[] dp = new long[number + 1];
            dp[1] = 3;
            dp[2] = 9;
            for(int i = 3; i <= number; i++){
                dp[i] = 2 * dp[i - 1] + dp[i - 2];
            }
            System.out.println(dp[number]);
        }
        
    }
        
}
